#include <addp/addp.hpp>

#include <iostream>
#include <string>

#define BOOST_TEST_MODULE addp_tests

#include <boost/numeric/conversion/converter_policies.hpp>
#include <boost/test/included/unit_test.hpp>

BOOST_AUTO_TEST_CASE(mac_address_stream) {
  addp::mac_address mac {"01:20:03:4d:fe:ef"};
  std::ostringstream os;
  os << mac;
  BOOST_CHECK_EQUAL(os.str(), "01:20:03:4d:fe:ef");
}

BOOST_AUTO_TEST_CASE(mac_address_parse) {
  addp::mac_address mac("01:20:03:4d:fe:ef");
  BOOST_CHECK_EQUAL(mac[0], 0x01);
  BOOST_CHECK_EQUAL(mac[1], 0x20);
  BOOST_CHECK_EQUAL(mac[2], 0x03);
  BOOST_CHECK_EQUAL(mac[3], 0x4d);
  BOOST_CHECK_EQUAL(mac[4], 0xfe);
  BOOST_CHECK_EQUAL(mac[5], 0xef);
}

BOOST_AUTO_TEST_CASE(mac_address_parse_windows_notation) {
  addp::mac_address mac("01-20-03-4D-FE-EF");
  BOOST_CHECK_EQUAL(mac.ToString(), "01:20:03:4d:fe:ef");
}

BOOST_AUTO_TEST_CASE(mac_address_parse_digi_notation) {
  addp::mac_address mac("012003:4dfeef");
  BOOST_CHECK_EQUAL(mac.ToString(), "01:20:03:4d:fe:ef");
  BOOST_CHECK_EQUAL(mac.ToDigiMac(), "012003:4DFEEF");
}

BOOST_AUTO_TEST_CASE(mac_address_dont_parse_octal) {
  addp::mac_address mac("01:02:03:07:08:09");
  std::ostringstream os;
  os << mac;
  BOOST_CHECK_EQUAL(os.str(), "01:02:03:07:08:09");
}

BOOST_AUTO_TEST_CASE(mac_address_parse_hex_to_lower) {
  addp::mac_address mac("01:23:45:67:89:AB");
  std::ostringstream os;
  os << mac;
  BOOST_CHECK_EQUAL(os.str(), "01:23:45:67:89:ab");
}

BOOST_AUTO_TEST_CASE(mac_address_throw_on_value_underflow) {
  BOOST_CHECK_THROW(addp::mac_address("01:23:45:67:89:-1"), boost::numeric::negative_overflow);
}

BOOST_AUTO_TEST_CASE(guid_to_string) {
  std::ostringstream os;
  addp::guid guid{0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
                  0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04};
  os << guid;
  BOOST_CHECK_EQUAL(os.str(), "01020304-01020304-01020304-01020304");
}

template<typename... Ts>
std::array<std::byte, sizeof...(Ts)> make_data(Ts&&... args) {
  return{std::byte(std::forward<Ts>(args))...};
}

BOOST_AUTO_TEST_CASE(parse_packet) {
  const auto bytes = make_data(
      0x44, 0x49, 0x47, 0x49, 0x0,  0x2,  0x0,  0x72, 0x1,  0x6,  0x0,  0x40, 0x9d, 0xc7,
      0x2d, 0x3f, 0x2,  0x4,  0xc0, 0xa8, 0x6,  0xb9, 0x3,  0x4,  0xff, 0xff, 0xff, 0x0,
      0xb,  0x4,  0xc0, 0xa8, 0x5,  0x1,  0x4,  0xa,  0x6a, 0x6f, 0x72, 0x69, 0x73, 0x5f,
      0x74, 0x65, 0x73, 0x74, 0xd,  0xf,  0x44, 0x69, 0x67, 0x69, 0x20, 0x43, 0x6f, 0x6e,
      0x6e, 0x65, 0x63, 0x74, 0x20, 0x4d, 0x45, 0x10, 0x1,  0x1,  0xf,  0x4,  0x8,  0x8,
      0x8,  0x8,  0x7,  0x1,  0x0,  0x8,  0x1e, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
      0x20, 0x38, 0x32, 0x30, 0x30, 0x30, 0x38, 0x35, 0x36, 0x5f, 0x46, 0x37, 0x20, 0x30,
      0x34, 0x2f, 0x32, 0x34, 0x2f, 0x32, 0x30, 0x31, 0x37, 0xe,  0x4,  0x0,  0x0,  0x3,
      0x3,  0x13, 0x4,  0x0,  0x0,  0x4,  0x3,  0x12, 0x1,  0x1);
  addp::response resp{bytes.data(), std::size(bytes)};
  BOOST_CHECK_EQUAL(resp.fields().size(), 12);
  BOOST_CHECK_EQUAL(resp.mac(), addp::mac_address{"00:40:9d:c7:2d:3f"});
  BOOST_CHECK_EQUAL(std::get<boost::asio::ip::address_v4>(resp[addp::field_type::ip_addr]).to_string(), "192.168.6.185");
  BOOST_CHECK_EQUAL(std::get<std::string_view>(resp[addp::field_type::firmware]), "Version 82000856_F7 04/24/2017");
}

BOOST_AUTO_TEST_CASE(parse_packet_too_small) {
  // Hack embedded length + 6
  const auto bytes = make_data(
      0x44, 0x49, 0x47, 0x49, 0x0,  0x2,  0x0,  0x72 + 6, 0x1,  0x6,  0x0,  0x40, 0x9d, 0xc7,
      0x2d, 0x3f, 0x2,  0x4,  0xc0, 0xa8, 0x6,  0xb9,     0x3,  0x4,  0xff, 0xff, 0xff, 0x0,
      0xb,  0x4,  0xc0, 0xa8, 0x5,  0x1,  0x4,  0xa,      0x6a, 0x6f, 0x72, 0x69, 0x73, 0x5f,
      0x74, 0x65, 0x73, 0x74, 0xd,  0xf,  0x44, 0x69,     0x67, 0x69, 0x20, 0x43, 0x6f, 0x6e,
      0x6e, 0x65, 0x63, 0x74, 0x20, 0x4d, 0x45, 0x10,     0x1,  0x1,  0xf,  0x4,  0x8,  0x8,
      0x8,  0x8,  0x7,  0x1,  0x0,  0x8,  0x1e, 0x56,     0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
      0x20, 0x38, 0x32, 0x30, 0x30, 0x30, 0x38, 0x35,     0x36, 0x5f, 0x46, 0x37, 0x20, 0x30,
      0x34, 0x2f, 0x32, 0x34, 0x2f, 0x32, 0x30, 0x31,     0x37, 0xe,  0x4,  0x0,  0x0,  0x3,
      0x3,  0x13, 0x4,  0x0,  0x0,  0x4,  0x3,  0x12,     0x1,  0x1);
  BOOST_CHECK_THROW(addp::response(bytes.data(), std::size(bytes)), std::runtime_error);
}

BOOST_AUTO_TEST_CASE(version_checks) {
  BOOST_CHECK_EQUAL(addp::field::ParseFirmwareVersion("Version 82000856_F7 04/24/2017"), "82000856_F7");
  BOOST_CHECK(!addp::field::SuggestedFirmwareUpgrade("82000856_F7").has_value());
  BOOST_CHECK_EQUAL(addp::field::SuggestedFirmwareUpgrade("82000856_F6").value(), "82000856_F7");
}
